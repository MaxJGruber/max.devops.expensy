name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  BACKEND_IMAGE: ${{ secrets.DOCKER_HUB_USERNAME }}/expensy-backend
  FRONTEND_IMAGE: ${{ secrets.DOCKER_HUB_USERNAME }}/expensy-frontend

jobs:
  # ============================================
  # Stage 0: Setup AKS Cluster (Get Ingress IP First)
  # ============================================
  setup-cluster:
    name: Setup AKS Cluster
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      ingress-ip: ${{ steps.get-ingress-ip.outputs.ip }}
      workspace-id: ${{ steps.log-analytics.outputs.workspace-id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Azure CLI extensions
        run: |
          az extension add --name aks-preview --upgrade || true

      - name: Create/Verify Log Analytics Workspace
        id: log-analytics
        run: |
          RESOURCE_GROUP="${{ secrets.AKS_RESOURCE_GROUP }}"
          WORKSPACE_NAME="${{ secrets.AKS_CLUSTER_NAME }}-logs"
          LOCATION="${{ secrets.AKS_LOCATION || 'westeurope' }}"

          echo "Checking if Log Analytics workspace exists..."
          WORKSPACE_ID=$(az monitor log-analytics workspace show \
            --resource-group "$RESOURCE_GROUP" \
            --workspace-name "$WORKSPACE_NAME" \
            --query id -o tsv 2>/dev/null || true)

          if [ -z "$WORKSPACE_ID" ]; then
            echo "Creating Log Analytics workspace..."
            az group create --name "$RESOURCE_GROUP" --location "$LOCATION" || true
            WORKSPACE_ID=$(az monitor log-analytics workspace create \
              --resource-group "$RESOURCE_GROUP" \
              --workspace-name "$WORKSPACE_NAME" \
              --location "$LOCATION" \
              --retention-time 30 \
              --query id -o tsv)
            echo "✓ Workspace created: $WORKSPACE_ID"
          else
            echo "✓ Workspace already exists: $WORKSPACE_ID"
          fi

          echo "workspace-id=$WORKSPACE_ID" >> $GITHUB_OUTPUT

      - name: Create/Verify AKS Cluster
        run: |
          RESOURCE_GROUP="${{ secrets.AKS_RESOURCE_GROUP }}"
          CLUSTER_NAME="${{ secrets.AKS_CLUSTER_NAME }}"
          LOCATION="${{ secrets.AKS_LOCATION || 'westeurope' }}"
          NODE_COUNT="${{ secrets.AKS_NODE_COUNT || 1 }}"
          NODE_VM_SIZE="${{ secrets.AKS_NODE_VM_SIZE || 'Standard_D2s_v3' }}"

          echo "Checking if cluster exists..."
          if az aks show --resource-group "$RESOURCE_GROUP" --name "$CLUSTER_NAME" &> /dev/null; then
            echo "✓ Cluster $CLUSTER_NAME already exists"
            echo "Enabling Container Insights on existing cluster..."
            az aks enable-addons \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --addons monitoring \
              --workspace-resource-id "${{ steps.log-analytics.outputs.workspace-id }}" || echo "Container Insights may already be enabled"
          else
            echo "Creating resource group..."
            az group create \
              --name "$RESOURCE_GROUP" \
              --location "$LOCATION" || echo "Resource group may already exist"

            echo "Creating AKS cluster..."
            az aks create \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --node-count "$NODE_COUNT" \
              --node-vm-size "$NODE_VM_SIZE" \
              --enable-managed-identity \
              --generate-ssh-keys \
              --location "$LOCATION" \
              --enable-addons monitoring \
              --workspace-resource-id "${{ steps.log-analytics.outputs.workspace-id }}"
          fi

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Verify Container Insights
        run: |
          RESOURCE_GROUP="${{ secrets.AKS_RESOURCE_GROUP }}"
          CLUSTER_NAME="${{ secrets.AKS_CLUSTER_NAME }}"

          echo "================================"
          echo "Checking Container Insights Status"
          echo "================================"

          echo ""
          echo "1. Addon Profile Status:"
          az aks show \
            --resource-group "$RESOURCE_GROUP" \
            --name "$CLUSTER_NAME" \
            --query "addonProfiles.omsagent" -o json || echo "omsagent addon not found"

          echo ""
          echo "2. Checking Log Analytics Workspace:"
          az aks show \
            --resource-group "$RESOURCE_GROUP" \
            --name "$CLUSTER_NAME" \
            --query "addonProfiles.omsagent.config.logAnalyticsWorkspaceResourceID" -o tsv || echo "Workspace ID not found"

          echo ""
          echo "3. Checking for oma-logs DaemonSet:"
          kubectl get daemonset -n kube-system | grep -i oma || echo "oma-logs not yet deployed (may take a few minutes)"

          echo ""
          echo "✓ Container Insights verification complete"

      - name: Verify Cluster Connection
        run: kubectl cluster-info

      - name: Create Namespace
        run: kubectl apply -f ./k8s/namespace.yaml

      - name: Install NGINX Ingress Controller
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update

          if helm list -n ingress-nginx 2>/dev/null | grep -q "ingress-nginx"; then
            echo "✓ Ingress controller already installed"
          else
            helm install ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --create-namespace \
              --set controller.resources.requests.cpu=50m \
              --set controller.resources.requests.memory=90Mi \
              --set controller.resources.limits.cpu=200m \
              --set controller.resources.limits.memory=256Mi
          fi

      - name: Wait for Ingress Controller
        id: get-ingress-ip
        run: |
          echo "Waiting for ingress controller external IP..."
          for i in {1..30}; do
            IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx --template='{{ range .status.loadBalancer.ingress }}{{ .ip }}{{ end }}' 2>/dev/null || true)
            if [ -n "$IP" ]; then
              echo "✓ Ingress IP: $IP"
              echo "ip=$IP" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/30: Waiting for external IP..."
            sleep 10
          done
          echo "⚠️  External IP not yet assigned (may be pending)"
          exit 0

      - name: Create Secrets
        env:
          MONGO_USER: ${{ secrets.MONGO_USER }}
          MONGO_PASS: ${{ secrets.MONGO_PASS }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          DATABASE_URI: ${{ secrets.DATABASE_URI }}
          API_URL: http://${{ steps.get-ingress-ip.outputs.ip }}/api
          GRAFANA_USER: ${{ secrets.GRAFANA_USER }}
          GRAFANA_PASS: ${{ secrets.GRAFANA_PASS }}
        run: |
          kubectl create secret generic expensy-secrets \
            --from-literal=mongo_user="$MONGO_USER" \
            --from-literal=mongo_pass="$MONGO_PASS" \
            --from-literal=redis_password="$REDIS_PASSWORD" \
            --from-literal=database_uri="$DATABASE_URI" \
            --from-literal=API_URL="$API_URL" \
            --from-literal=grafana_user="$GRAFANA_USER" \
            --from-literal=grafana_pass="$GRAFANA_PASS" \
            --namespace expensy \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Print Cluster Summary
        run: |
          echo "================================"
          echo "✓ Cluster Setup Completed"
          echo "================================"
          echo "Resource Group: ${{ secrets.AKS_RESOURCE_GROUP }}"
          echo "Cluster Name: ${{ secrets.AKS_CLUSTER_NAME }}"
          echo "Ingress Namespace: ingress-nginx"
          echo "Ingress IP: ${{ steps.get-ingress-ip.outputs.ip }}"
          echo ""
          echo "Useful commands:"
          echo "  View pods: kubectl get pods -n expensy"
          echo "  View services: kubectl get svc -n expensy"
          echo "  View ingress: kubectl get svc -n ingress-nginx"

  # ============================================
  # Stage 1: Docker Build & Push
  # ============================================
  docker-build-push:
    name: Docker Build & Push
    runs-on: ubuntu-latest
    needs: [setup-cluster]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata for Backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and Push Backend Image
        uses: docker/build-push-action@v5
        with:
          context: ./expensy_backend
          file: ./expensy_backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Extract metadata for Frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest

      - name: Build and Push Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: ./expensy_frontend
          file: ./expensy_frontend/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=http://${{ needs.setup-cluster.outputs.ingress-ip }}
  # ============================================
  # Stage 2: Deploy to Staging
  # ============================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [docker-build-push, setup-cluster]
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}

      - name: Deploy to Staging
        env:
          MONGO_USER: ${{ secrets.MONGO_USER }}
          MONGO_PASS: ${{ secrets.MONGO_PASS }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          DATABASE_URI: ${{ secrets.DATABASE_URI }}
          API_URL: http://${{ needs.setup-cluster.outputs.ingress-ip }}
          GRAFANA_USER: ${{ secrets.GRAFANA_USER }}
          GRAFANA_PASS: ${{ secrets.GRAFANA_PASS }}
        run: |
          # Step 1: Delete existing secret to force update
          kubectl delete secret expensy-secrets -n expensy --ignore-not-found=true
          sleep 2

          # Step 2: Create secrets first (before any deployments)
          envsubst < k8s/secrets.yaml | kubectl apply -f - -n expensy

          # Step 3: Wait for secret to be ready
          kubectl get secret expensy-secrets -n expensy -o jsonpath='{.metadata.name}' 2>/dev/null || sleep 1

          # Step 4: Update image tags in deployment manifests (NOT secrets.yaml)
          sed -i "s|IMAGE_TAG|${{ github.sha }}|g" k8s/deployment*.yaml k8s/backend*.yaml k8s/frontend*.yaml 2>/dev/null || true

          # Step 5: Apply all other Kubernetes manifests (excluding secrets)
          for file in k8s/*.yaml; do
            [ "$file" != "k8s/secrets.yaml" ] && kubectl apply -f "$file" -n expensy
          done

          # Step 6: Force pod restart to pick up new secrets
          kubectl rollout restart deployment/backend -n expensy
          kubectl rollout restart deployment/frontend -n expensy
          kubectl rollout restart deployment/grafana -n expensy

          # Step 7: Wait for rollout to complete
          kubectl rollout status deployment/backend -n expensy --timeout=300s
          kubectl rollout status deployment/frontend -n expensy --timeout=300s
          kubectl rollout status deployment/prometheus -n expensy --timeout=300s
          kubectl rollout status deployment/grafana -n expensy --timeout=300s

      - name: Run Smoke Tests
        run: |
          echo "Running smoke tests against staging environment..."
          # Add your smoke test commands here
          sleep 10
          echo "Smoke tests passed!"

  # ============================================
  # Stage 3: Deploy to Production (Manual Approval)
  # ============================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://expensy.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ secrets.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ secrets.AKS_CLUSTER_NAME }}

      - name: Deploy to Production
        env:
          MONGO_USER: ${{ secrets.MONGO_USER }}
          MONGO_PASS: ${{ secrets.MONGO_PASS }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          DATABASE_URI: ${{ secrets.DATABASE_URI }}
          API_URL: http://${{ needs.setup-cluster.outputs.ingress-ip }}
          GRAFANA_USER: ${{ secrets.GRAFANA_USER }}
          GRAFANA_PASS: ${{ secrets.GRAFANA_PASS }}
        run: |
          # Step 1: Delete existing secret to force update
          kubectl delete secret expensy-secrets -n expensy --ignore-not-found=true
          sleep 2

          # Step 2: Create secrets first (before any deployments)
          envsubst < k8s/secrets.yaml | kubectl apply -f - -n expensy

          # Step 3: Wait for secret to be ready
          kubectl get secret expensy-secrets -n expensy -o jsonpath='{.metadata.name}' 2>/dev/null || sleep 1

          # Step 4: Update image tags in deployment manifests (NOT secrets.yaml)
          sed -i "s|IMAGE_TAG|${{ github.sha }}|g" k8s/deployment*.yaml k8s/backend*.yaml k8s/frontend*.yaml 2>/dev/null || true

          # Step 5: Apply all other Kubernetes manifests (excluding secrets)
          for file in k8s/*.yaml; do
            [ "$file" != "k8s/secrets.yaml" ] && kubectl apply -f "$file" -n expensy
          done

          # Step 6: Force pod restart to pick up new secrets
          kubectl rollout restart deployment/backend -n expensy
          kubectl rollout restart deployment/frontend -n expensy
          kubectl rollout restart deployment/grafana -n expensy

          # Step 7: Wait for rollout to complete
          kubectl rollout status deployment/backend -n expensy --timeout=300s
          kubectl rollout status deployment/frontend -n expensy --timeout=300s
          kubectl rollout status deployment/prometheus -n expensy --timeout=300s
          kubectl rollout status deployment/grafana -n expensy --timeout=300s

      - name: Verify Deployment
        run: |
          echo "Verifying production deployment..."
          kubectl get pods -n expensy
          kubectl get services -n expensy
          echo "Production deployment verified!"
